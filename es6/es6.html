<!--
    Powered By nodeppt - This is probably the best web presentation tool so far!
    version: 1.4.5
    site: https://github.com/ksky521/nodeppt
    date: 2017年6月30号
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ES6 - By Judith Huang</title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/monokai_sublime.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.dark.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ES6</h1>
<p><small>演讲者：Judith Huang</small></p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>let 命令</h1>

</hgroup><article>

<ul>
<li>基本用法:<br>ES6 新增了 <code>let</code> 命令，用来声明变量。它的用法类似于 <code>var</code> , 但是所声明的变量，只在 <code>let</code> 命令的代码块内有效。</li>
</ul>
<pre><code class="js">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre>
<ul>
<li>不存在变量提升<br><code>var</code> 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 <code>undefined</code>。
<code>let</code> 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</li>
</ul>
<pre><code class="js">// var 的情况
console.log(number); // 输出undefined
var number = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>let 命令</h1>

</hgroup><article>

<ul>
<li>暂时性死区:<br>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br>下面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</li>
</ul>
<pre><code class="js">var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>let 命令</h1>

</hgroup><article>

<ul>
<li>不允许重复声明:<br>let不允许在相同作用域内，重复声明同一个变量。</li>
</ul>
<pre><code class="js">// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>const 命令</h1>

</hgroup><article>

<p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。
<code>const</code> 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code class="js">const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>变量的解构赋值</h1>

</hgroup><article>

<ul>
<li>数据的解构赋值:<br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</li>
</ul>
<pre><code class="js">// 以前写法
let a = 1;
let b = 2;
let c = 3;

// ES6写法
let [a, b, c] = [1, 2, 3];

// 解构设置默认值, 如果一个数组成员不严格等于undefined，默认值是不会生效的
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>变量的解构赋值</h1>

</hgroup><article>

<ul>
<li>对象的解构赋值<br>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li>
</ul>
<pre><code class="js">let { name } = { name: &quot;Tom&quot; };
name // &quot;Tom&quot;

// 如果变量名与属性名不一致
let { name: myName } = { name: &quot;Tom&quot; };
myName // Tom

// 解构设置默认值
let { name: myName = &quot;Tim&quot; } = { };
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>变量的解构赋值</h1>

</hgroup><article>

<ul>
<li>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</li>
</ul>
<pre><code class="js">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>变量的解构赋值</h1>

</hgroup><article>

<ul>
<li>函数参数的解构赋值<br>函数 <code>add</code> 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 <code>x</code> 和 <code>y</code> 。对于函数内部的代码来说，它们能感受到的参数就是 <code>x</code> 和 <code>y</code> 。</li>
</ul>
<pre><code class="js">function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>字符串的扩展</h1>

</hgroup><article>

<ul>
<li>字符串的遍历器接口<br>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。</li>
</ul>
<pre><code class="js">for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre>
<ul>
<li><p>includes(), startsWith(), endsWith()<br>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。这三个方法都支持第二个参数，表示开始搜索的位置</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>字符串的扩展</h1>

</hgroup><article>

<ul>
<li>模板字符串<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>字符串的扩展</h1>

</hgroup><article>

<ul>
<li>模板字符串<br>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</li>
</ul>
<pre><code class="js">const name = &quot;Bob&quot;, time = &quot;today&quot;;

// es5
&#39;Hello &#39; + name + &#39;, how are you &#39; + time + &#39;?&#39; 

// es6
`Hello ${name}, how are you ${time}?`
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>数组的扩展</h1>

</hgroup><article>

<ul>
<li>扩展运算符<br>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</li>
</ul>
<pre><code class="js">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>数组的扩展</h1>

</hgroup><article>

<ul>
<li>Array.from()</li>
<li>Array.of()</li>
<li>数组实例的 copyWithin()</li>
<li>数组实例的 find() 和 findIndex()</li>
<li>数组实例的fill()</li>
<li>数组实例的 entries()，keys() 和 values()</li>
<li>数组实例的 includes()</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>对象的扩展</h1>

</hgroup><article>

<ul>
<li>属性的简洁表示法<br>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</li>
</ul>
<pre><code class="js">var foo = &#39;bar&#39;;
var baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
var baz = {foo: foo};
</code></pre>
<ul>
<li>属性名表达式<br>下面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</li>
</ul>
<pre><code class="js">// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>对象的扩展</h1>

</hgroup><article>

<ul>
<li>Object.assign<br>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
</ul>
<pre><code class="js">var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>对象的扩展</h1>

</hgroup><article>

<ul>
<li>对象的扩展运算符    <ul>
<li>解构赋值: 对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</li>
<li>扩展运算符: 扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</li>
</ul>
</li>
</ul>
<pre><code class="js">// 1. 解构赋值
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }

// 2. 扩展运算符
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Symbol</h1>

</hgroup><article>

<ul>
<li>概述<br>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<br>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</li>
</ul>
<pre><code class="js">let s = Symbol();

typeof s; // &quot;symbol&quot;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Promise 对象</h1>

</hgroup><article>

<ul>
<li>基本用法<br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Promise 对象</h1>

</hgroup><article>

<pre><code class="js">var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Class 的基本语法</h1>

</hgroup><article>

<ul>
<li>简介<br>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</li>
</ul>
<p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Class 的基本语法</h1>

</hgroup><article>

<ul>
<li>简介    <ul>
<li>constructor: 类的默认方法，通过new命令生成对象实例时，自动调用该方法</li>
<li>静态方法: 该方法不会被实例继承，而是直接通过类来调用</li>
<li>私有方法: ES6 不提供, 可以命名上加以区别</li>
</ul>
</li>
</ul>
<pre><code class="js">class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  // 公有方法
  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }

  static sayHello() {
    return &#39;hello&#39;;
  }

  _private() {
    console.log(&#39;This is a private method&#39;);
  }
}

const point = new Point(0, 0);
point.toString();
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>Module 的语法</h1>

</hgroup><article>

<p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<pre><code class="js">// profile.js
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export {firstName, lastName, year};

// main.js
import {firstName, lastName, year} from &#39;./profile&#39;;
function setName(element) {
  element.textContent = firstName + &#39; &#39; + lastName;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><hgroup>
<h1>转码器</h1>

</hgroup><article>

<ul>
<li><a href="http://babeljs.io/" target="_blank">Babel</a></li>
<li><a href="https://github.com/google/traceur-compiler" target="_blank">Traceur</a></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>reference</h1>
<ul>
<li><a href="http://es6.ruanyifeng.com/" target="_blank">ECMAScript 6 入门</a></li>
<li><a href="https://github.com/lukehoban/es6features" target="_blank">ES6 Features</a></li>
</ul>

</article></section></slide>
        

        <!-- <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
                <h2 style="color: white;">Powered By nodeppt v1.4.5</h2>
            </article>
        </slide> -->
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
    var ASSET_RELATIVE_DIR = ".";
</script>
<script>
var base = location.protocol + '//' + location.host;

var path = (location.pathname + '#').split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
if (typeof ASSET_RELATIVE_DIR === 'string') {
    path = path + '/' + ASSET_RELATIVE_DIR;
}
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'slide3',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/highlight.pack.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>


<!--placeholder-->
</body>
</html>
